<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=640" />

    <link rel="stylesheet" href="stylesheets/core.css" media="screen"/>
    <link rel="stylesheet" href="stylesheets/mobile.css" media="handheld, only screen and (max-device-width:640px)"/>
    <link rel="stylesheet" href="stylesheets/pygment_trac.css"/>

    <script type="text/javascript" src="javascripts/modernizr.js"></script>
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script type="text/javascript" src="javascripts/headsmart.min.js"></script>
    <script type="text/javascript">
      $(document).ready(function () {
        $('#main_content').headsmart()
      })
    </script>
    <title>CSS在WebKit和Blink下的区域绘制 by Yangxue1988</title>
  </head>

  <body>
    <a id="forkme_banner" href="https://github.com/Yangxue1988/Yangxue1988-Yangxue1988.github.io">View on GitHub</a>
    <div class="shell">

      <header>
        <span class="ribbon-outer">
          <span class="ribbon-inner">
            <h1>CSS在WebKit和Blink下的区域绘制</h1>
            <h2>由安德烈•布库尔发表于2013年10月28日</h2>
          </span>
          <span class="left-tail"></span>
          <span class="right-tail"></span>
        </span>
      </header>

      <section id="downloads">
        <span class="inner">
          <a href="https://github.com/Yangxue1988/Yangxue1988-Yangxue1988.github.io/zipball/master" class="zip"><em>download</em> .ZIP</a><a href="https://github.com/Yangxue1988/Yangxue1988-Yangxue1988.github.io/tarball/master" class="tgz"><em>download</em> .TGZ</a>
        </span>
      </section>


      <span class="banner-fix"></span>


      <section id="main_content">
        <p><a href="http://blogs.adobe.com/webplatform/2013/10/28/css-regions-painting-in-webkit-and-blink/">http://blogs.adobe.com/webplatform/2013/10/28/css-regions-painting-in-webkit-and-blink/</a></p>

<p>    CSS 2.1规范定义了一个盒模型用来显示文档里面的内容。WebKit和Blink引擎遵守本规范并且予以实现，那么，假设当显示一个文档布局时，布局的元素作为一个单独的盒子，在混合添加碎片时，你可能最终为一个单一的元素使用了多个盒子。这意味着，引擎必须做一些技巧来正确渲染盒子片段。大多数碎片实现方面都覆盖在我以前的博客“WebKit的CSS中的碎片”里。在这篇文章中，我想专注于CSS的区域绘制是如何实现的。</p>

<p>图1</p>

<p>    让我们考虑一个文档，定义一个指定的流（一个RenderFlowThread对象）包含一个流过3个指定宽高的区域的大段落。第一步中，布局中只有body元素的内容，忽略指定流中的元素。此步中，将计算页面中这个区域（RenderRegion对象）的大小和位置。在第二步中，引擎勾画出流线程的内容。正如你可以看到的，各地区有不同的宽度，这将影响线框的大小。在图1中，可以看到布局后的流线程草图。段落的每一个片段是不同的颜色，以反映该区域将被定位的地方。规范地说，流线的宽度是最宽的区域的宽度（在我们的案例中，是区域三）。通过利用存储在RenderBoxRegionInfo类型对象的信息，每个区域内容块的宽度决定了线框的宽度。他们包含需要调整的每一个区域块的宽度值。剩余的上一个区域的最后一行，到下一个区域的第一行之间的空白是分页支柱（在图1中灰色箭头表示的），内容的偏移是为了模拟自然断点。因为流线程的高度是所有区域高度的总和，如果内容太多，包括所有区域的内容将会溢出流线程（见流线程的底部）。</p>

<p>图2
     内容片断的真证被渲染是在绘图的时候。当一个区域将要被绘制时，它会调整制图背景的位置，以及抵消流线程层，以便绘制能在区域内容盒内部的正确位置。流线程的整个内容利用RenderBoxRegionInfo对象调整它的宽度，所以一切看起来都像在区域内部的一样（例如边框和阴影等）。部分流线程并不和预期的一样（例如属于其它区域的部分），它们被裁剪如图2的灰色部分那样。在最后一个区域，你可以看到底部溢出的区域没有被裁剪。这是因为裁剪是利用了RenderFlowThread的视觉溢出，包括所有的内容都没有自绘制的层。流线程的内容（包括溢出）被区域内容盒子分开，区域绘制仅仅是流的一部分。在绘制过程的最后，文档流看起来像如下图3，每个区域包括流的一部分，在最后一个区域的溢出是可见的。</p>

<p>图3
我们目前正在研究的最重要的改进是把流线程的绘制委托给区域层，而不是目前实现的区域渲染。这能使我们结合流线程绘制和树层结构，并且修复一些保留在实现层面的主要的bug（例如：对相对定位溢出区域的错误裁剪）。</p>
      </section>

      <footer>
        <span class="ribbon-outer">
          <span class="ribbon-inner">
            <p>this project by <a href="https://github.com/Yangxue1988">Yangxue1988</a> can be found on <a href="https://github.com/Yangxue1988/Yangxue1988-Yangxue1988.github.io">GitHub</a></p>
          </span>
          <span class="left-tail"></span>
          <span class="right-tail"></span>
        </span>
        <p>Generated with <a href="http://pages.github.com">GitHub Pages</a> using Merlot</p>
        <span class="octocat"></span>
      </footer>

    </div>

    
  </body>
</html>
